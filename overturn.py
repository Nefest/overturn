# -*- coding: utf-8 -*-
"""Overturn.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14JQTKjFHLxL3eC2xuA_57cC2DZfI27mV
"""

import itertools
import functools
import math
import matplotlib.pyplot as plt
import matplotlib.patches as patches
from typing import Iterator, Tuple, Callable

Point = Tuple[float, float]
Polygon = Tuple[Point, ...]
PolygonSequence = Iterator[Polygon]

"""Задание 1"""

def gen_squares(start: Point = (0, 0), step: float = 1.0) -> PolygonSequence:
    def square_at(x, y, size=1.0):
        return ((x, y), (x, y + size), (x + size, y + size), (x + size, y))

    return (square_at(x, y) for x, y in zip(itertools.count(start[0], step), itertools.count(start[1], step)))

def visualize_polygons(seq: PolygonSequence, n: int = 10):
    fig, ax = plt.subplots()
    for poly in itertools.islice(seq, n):
        patch = patches.Polygon(poly, closed=True, edgecolor='black', fill=False)
        ax.add_patch(patch)
    ax.set_aspect('equal')
    ax.set_xlim(0, 10)
    ax.set_ylim(0, 10)
    plt.grid(True)
    plt.show()

visualize_polygons(gen_squares(), n=10)

"""Задание 2"""

def gen_rectangle(width=1.0, height=1.0) -> Iterator[Tuple[Polygon, float]]:
    while True:
        yield (((0, 0), (0, height), (width, height), (width, 0)), width)

def gen_triangle(side=1.0) -> Iterator[Tuple[Polygon, float]]:
    h = side * math.sqrt(3) / 2
    while True:
        yield (((0, 0), (side / 2, h), (side, 0)), side)

def gen_hexagon(radius=1.0) -> Iterator[Tuple[Polygon, float]]:
    dx = radius * 2 * math.cos(math.radians(30))
    def hexagon():
        return tuple(
            (radius * math.cos(math.radians(a)), radius * math.sin(math.radians(a)))
            for a in range(0, 360, 60)
        )
    while True:
        yield (hexagon(), dx)


def shift_polygon(polygon: Polygon, dx: float, dy: float = 0) -> Polygon:
    return tuple((x + dx, y + dy) for x, y in polygon)

def combine_shifted(*generators, count=7, gap=0.5) -> Iterator[Polygon]:
    all_gens = itertools.cycle(generators)
    current_x = 0.0

    for _ in range(count):
        gen = next(all_gens)
        polygon, width = next(gen)
        shifted = shift_polygon(polygon, dx=current_x)
        yield shifted
        current_x += width + gap


def visualize_polygons(seq: Iterator[Polygon], n: int = 7):
    fig, ax = plt.subplots()
    polys = list(itertools.islice(seq, n))

    for poly in polys:
        patch = patches.Polygon(poly, closed=True, edgecolor='black', fill=False)
        ax.add_patch(patch)

    all_x = [x for poly in polys for x, _ in poly]
    all_y = [y for poly in polys for _, y in poly]
    ax.set_xlim(min(all_x) - 1, max(all_x) + 1)
    ax.set_ylim(min(all_y) - 1, max(all_y) + 1)

    ax.set_aspect('equal')
    ax.grid(True)
    plt.show()

combined = itertools.islice(
    itertools.chain(
        itertools.islice(gen_rectangle(), 3),
        itertools.islice(gen_triangle(), 2),
        itertools.islice(gen_hexagon(), 2),
        ),
        7
    )

rectangles = gen_rectangle(width=1.5, height=1.0)
triangles = gen_triangle(side=1.2)
hexagons = gen_hexagon(radius=0.9)

sequence = combine_shifted(rectangles, triangles, hexagons, count=10)

visualize_polygons(sequence, n=10)

"""Задание 3"""

def tr_translate(dx: float, dy: float):
    return lambda polygon: tuple((x + dx, y + dy) for x, y in polygon)

def tr_rotate(angle_deg: float, cx=0.0, cy=0.0):
    angle_rad = math.radians(angle_deg)
    cos_a, sin_a = math.cos(angle_rad), math.sin(angle_rad)

    def rotate_point(x, y):
        x -= cx
        y -= cy
        return (
            cx + x * cos_a - y * sin_a,
            cy + x * sin_a + y * cos_a
        )

    return lambda polygon: tuple(rotate_point(x, y) for x, y in polygon)

def tr_symmetry(axis: str):
    if axis == 'x':
        return lambda poly: tuple((x, -y) for x, y in poly)
    elif axis == 'y':
        return lambda poly: tuple((-x, y) for x, y in poly)
    elif axis == 'origin':
        return lambda poly: tuple((-x, -y) for x, y in poly)
    else:
        raise ValueError("axis must be 'x', 'y', or 'origin'")

def tr_homothety(k: float, cx=0.0, cy=0.0):
    return lambda poly: tuple(((x - cx) * k + cx, (y - cy) * k + cy) for x, y in poly)

original_seq = combine_shifted(
    gen_rectangle(width=1.5, height=1.0),
    gen_triangle(side=1.2),
    gen_hexagon(radius=0.9),
    count=7
)

rotated_seq = map(tr_rotate(45), original_seq)

visualize_polygons(rotated_seq, n=7)

"""Задание 4"""

def angled_bands():
    angle = 30
    count = 7
    spacing = 2.5

    rects = map(tr_rotate(angle), combine_shifted(gen_rectangle(), count=count))
    rects = map(tr_translate(0, 0), rects)

    tris = map(tr_rotate(angle), combine_shifted(gen_triangle(), count=count))
    tris = map(tr_translate(0, spacing), tris)

    hexs = map(tr_rotate(angle), combine_shifted(gen_hexagon(), count=count))
    hexs = map(tr_translate(0, spacing * 2), hexs)

    visualize_polygons(itertools.chain(rects, tris, hexs), n=count * 3)

def crossing_bands():
    count = 10
    shift = 4

    band1 = map(tr_rotate(45), combine_shifted(gen_rectangle(), count=count))
    band1 = map(tr_translate(-shift, -shift), band1)

    band2 = map(tr_rotate(-45), combine_shifted(gen_hexagon(), count=count))
    band2 = map(tr_translate(-shift/2, shift), band2)

    visualize_polygons(itertools.chain(band1, band2), n=count * 2)

def mirrored_triangles():
    count = 7
    up = list(combine_shifted(gen_triangle(), count=count))
    down = list(map(tr_symmetry('x'), up))
    down = list(map(tr_translate(0, -2), down))

    visualize_polygons(itertools.chain(up, down), n=count * 2)

def cone_of_scaled_quads():
    count = 6
    angles = [+30, +210]
    spacing = 2
    base = list(itertools.islice(gen_rectangle(width=1.5, height=1.0), count))
    polygons = [p[0] for p in base]
    scales = [0.5 + i * 0.2 for i in range(count)]

    all_polygons = []

    for angle_deg in angles:
        angle_rad = math.radians(angle_deg)
        dx = math.cos(angle_rad)
        dy = math.sin(angle_rad)

        for i, (poly, scale) in enumerate(zip(polygons, scales)):
            scaled = tr_homothety(scale)(poly)
            rotated = tr_rotate(angle_deg)(scaled)
            shift_x = i * spacing * dx
            shift_y = i * spacing * dy
            shifted = tr_translate(shift_x, shift_y)(rotated)
            all_polygons.append(shifted)

    visualize_polygons(all_polygons, n=len(all_polygons))



angled_bands()
crossing_bands()
mirrored_triangles()
cone_of_scaled_quads()

"""Задание 5"""

def flt_convex_polygon(polygon: Polygon) -> bool:
    def cross_sign(a, b, c):
        ab = (b[0] - a[0], b[1] - a[1])
        bc = (c[0] - b[0], c[1] - b[1])
        return ab[0]*bc[1] - ab[1]*bc[0]

    signs = []
    n = len(polygon)
    for i in range(n):
        sign = cross_sign(polygon[i], polygon[(i + 1) % n], polygon[(i + 2) % n])
        signs.append(sign > 0)

    return all(signs) or not any(signs)



def flt_angle_point(p: Point):
    return lambda poly: any(v == p for v in poly)



def polygon_area(polygon: Polygon) -> float:
    area = 0.0
    n = len(polygon)
    for i in range(n):
        x1, y1 = polygon[i]
        x2, y2 = polygon[(i + 1) % n]
        area += x1 * y2 - x2 * y1
    return abs(area) / 2.0

def flt_square(threshold: float):
    return lambda poly: polygon_area(poly) < threshold



def side_length(a: Point, b: Point) -> float:
    return math.hypot(a[0] - b[0], a[1] - b[1])

def flt_short_side(min_length: float):
    def check(poly):
        n = len(poly)
        return any(side_length(poly[i], poly[(i+1)%n]) < min_length for i in range(n))
    return check



def flt_point_inside(p: Point):
    def is_inside(poly: Polygon) -> bool:
        def sign(o, a, b):
            return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])

        signs = []
        n = len(poly)
        for i in range(n):
            a = poly[i]
            b = poly[(i+1) % n]
            s = sign(p, a, b)
            signs.append(s >= 0)
        return all(signs) or not any(signs)
    return is_inside


def flt_polygon_angles_inside(ref_poly: Polygon):
    def contains_any(polygon: Polygon) -> bool:
        def sign(o, a, b):
            return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])

        def is_inside(p: Point) -> bool:
            signs = []
            n = len(polygon)
            for i in range(n):
                a = polygon[i]
                b = polygon[(i+1) % n]
                s = sign(p, a, b)
                signs.append(s >= 0)
            return all(signs) or not any(signs)

        return any(is_inside(v) for v in ref_poly)

    return contains_any

"""Задание 6"""

def generate_scaled_figures() -> PolygonSequence:
    rect_gen = gen_rectangle()
    tri_gen = gen_triangle()
    hex_gen = gen_hexagon()

    scales = [0.5 + 0.1 * i for i in range(15)]

    gens = itertools.cycle([rect_gen, tri_gen, hex_gen])

    for scale in scales:
        poly, _ = next(next(gens))
        scaled = tr_homothety(scale)(poly)
        yield scaled

def filter_short_sides(polygons: PolygonSequence, max_side_length: float, max_count: int = 4):
    return itertools.islice(
        filter(flt_short_side(max_side_length), polygons),
        max_count
    )

all_figures = generate_scaled_figures()
selected = filter_short_sides(all_figures, 1.2)
visualize_polygons(selected, n=4)